---
hide:
  - footer
---

# 보수(Complement)

---

## 1. 키워드

- 보수(Complement)
- 1의 보수(Ones' Complement)
- 2의 보수(Two's Complement)
- 비트 반전 연산자(`~`)

<br/>

## 2. 보수(Complement)

### 1) 보수란?

- 보수란 보충을 해주는 수를 말하며, 두 수의 합이 진법의 밑수가 되게 하는 수를 의미한다.
- 예를 들어 8비트 이진수 `0000 0100` 1의 보수는 이진수 `1111 1011`이고, 이진수 `0001 1010`의 1의 보수는 이진수 `1110 0101`이 된다.

<br/>

### 2) 1의 보수(Ones' Complement)

- 1의 보수란 2의 거듭제곱수-1에서 빼서 얻은 이진수를 말하며, 비트를 반전시켜서 얻을 수 있다.
- 다음의 예제는 1의 보수를 얻는 것을 보여주는 예제이다.

```java
8비트 이진수 0000 1101 // 십진수 13

0 000 1101 // 부호 비트는 0 -> 양수
```

- 1의 보수는 다음과 같이 해당 이진수와 자리수가 같고 모든 자리가 `1`인 수에서 해당 이진수를 빼서 얻을 수 있다.

```java
  1111 1111
-) 0000 1101
------------
  1111 0010
```

- 또한, 단순히 비트를 반전시켜서 얻을 수도 있다.

```java
0000 1101 -> 1111 0010
```

- 1의 부호를 구해 보면, 양수였던 부호 비트가 음수가 되는 것을 알 수 있다.

<br/>

### 3) 2의 보수(Two's Complement)

- 2의 보수란 2의 거듭제곱수에서 빼서 얻은 이진수를 말하며, 1의 보수에 `1`을 더하여 얻을 수 있다.
- 일반적으로 부호를 바꿀 때 2의 보수 계산을 사용한다.
- 다음의 예제는 2의 보수를 얻는 것을 보여주는 예제이다.

```java
8비트 이진수 0000 1101 // 십진수 13

0 000 1101 // 부호 비트는 0 -> 양수
```

- 2의 보수는 일반적으로 부호를 바꿀 때 사용한다고 했다.
- 그러므로, 이진수 `0000 1101`에 그에 해당하는 음수를 더한다면 당연히 `0`이 되어야만 한다.
- 다음의 예제는 이진수 `0000 1101`의 2의 보수를 더하여 `0`이 되는지 확인해 보는 예제이다.

```java
// 1의 보수 계산
  1111 1111
-) 0000 1101
------------
  1111 0010

// 2의 보수 계산
  1111 0010
+) 0000 0001 // 1의 보수에 1을 더한 것이 2의 보수
------------
  1111 0011 // 이진수 0000 1101의 2의 보수

// 이진수 0000 1101과 2의 보수 1111 0011의 덧셈 연산
  0000 1101
+) 1111 0011
------------
 1 0000 0000
=) 0000 0000 // MSB 값인 1은 8비트를 넘어가므로 버림
```

- 위의 예제에서 이진수 `0000 1101`에 2의 보수 `1111 0011`을 더했더니 `0000 0000` 즉, `0`이 되는 것을 확인할 수 있다.
- 결과적으로, 어떠한 수의 부호를 바꿀 때에는 2의 보수를 사용하면 된다는 것을 알 수 있다.

<br/>

## 3. 비트 반전 연산자(`~`)와 보수

- 십진수 `x`에 비트 반전 연산자(`~`)를 적용하는 것이 1의 보수를 구한 것과 같다고 한다.
- 그리고 비트 반전 연산자를 적용한 결과는 항상 다음 예제와 같이 `-(x+1)`이 나오는데, 왜 이런 결과가 나오는지 알아보자.

```java
int num1 = 13;
System.out.println(~num1); // -14

int num2 = -13;
System.out.println(~num2); // 12
```

- 다음의 예제는 왜 위와 같은 결과가 나오는지 확인해 보는 예제이다.

```java
// 1의 보수 계산
  1111 1111
-) 0000 1101
-----------
  1111 0010 // 부호 비트는 1 -> 음수
```

- 십진수 `13`은 8비트 이진수 `0000 1101`이므로, `~(13) == ~(00001101)`이라고 할 수 있다.
- 그리고 비트 반전 연산자의 적용은 1의 보수 계산과 같으므로 이진수 `0000 1101`에 1의 보수를 계산하면 된다.
- 그 결과, 이진수 `0000 1101`의 1의 보수는 이진수 `1111 0010`가 되며, 음수가 된다는 사실은 이제 잘 알 수 있다.
- 이제 이 음수인 이진수 `1111 0010`은 십진수로 몇인지 확인해 보면 되는데, 이 자체로는 해당하는 십진수를 알 수 없기 때문에 양수로 다시 바꿔 줘야 한다.
- 음수인 이진수 `1111 0010`을 다음과 같이 2의 보수 계산을 통해 단순히 다시 양수로만 바꿔 보자.

```java
8비트 이진수 1111 0010

// 1의 보수 계산
  1111 1111
-) 1111 0010
------------
  0000 1101 // 십진수 13

// 2의 보수 계산
  0000 1101
+) 0000 0001
------------
  0000 1110 // 십진수 14
```

- 위의 예제에서 음수인 이진수 `1111 0010`을 2의 보수 계산을 통해 양수로 바꿔 줬더니 십진수 `14`가 된다는 것을 확인할 수 있다.
- 즉, 음수인 이진수 `1111 0010`의 부호만 바꾼 상태이기 때문에 음수인 이진수 `1111 0010`은 음수인 십진수 `14`와 동일하다고 볼 수 있으며, 이것은 `~(13) == ~(00001101) == 11110010 == -(14)`이라는 의미가 된다.

<br/>
